costs<-sfnetworks::st_network_cost(x = new.network,from = root.index,to = end.nodes)
costs2<-sort(costs,decreasing=T)
end.nodes2<-end.nodes[order(costs,decreasing=T)]
for(i in 1:length(end.nodes2)){
start.val<-max(network.table$newids)+1
path<-sfnetworks::st_network_paths(x = new.network,from = root.index,to = end.nodes2[i])$node_paths[[1]]
path2<-path[path!=root.index]
match.vec<-match(path2,new.edges$to)
match.vec2<-match.vec[network.table$newids[match.vec]==0]
network.table$newids[match.vec2]<-start.val:(start.val+length(match.vec2)-1)
}
new.edges$reachid<-network.table$newid[match(new.edges$reachid,network.table$oldid)]
new.edges<-new.edges[order(new.edges$reachid),]
# now can compute the parents, though this is going to be complicated by habitat/nonhabitat
new.edges$parent<-new.edges$reachid[match(new.edges$from,new.edges$to)]
new.parent.vec<-rep(NA,nrow(new.edges))
parent.distance.vec<-rep(NA,nrow(new.edges))
# now account for habitat
for(i in 1:nrow(new.edges)){
if(new.edges$root[i]==F){
parent<-new.edges$parent[i]
# if the parent is habitat, things are easy
if(new.edges$habitat[parent]){
new.parent.vec[i]<-parent
parent.distance.vec[i]<-.5*sf::st_length(new.edges)[i]+.5*sf::st_length(new.edges)[parent]
}else{
# loop through to parent is easier than converting to network
bad.parent<-T
path.segs<-parent
active.seg<-parent
while(bad.parent){
new.parent<-new.edges$parent[active.seg]
if(new.edges$habitat[new.parent]){
bad.parent<-F
}else{
path.segs<-c(path.segs,new.parent)
active.seg<-new.parent
}
}
new.parent.vec[i]<-new.parent
parent.distance.vec[i]<-.5*sf::st_length(new.edges)[i]+.5*sf::st_length(new.edges)[new.parent]+
sum(sf::st_length(new.edges)[path.segs])
}
}
}
new.edges$parent<-new.parent.vec
new.edges$parent.distance<-as.numeric(parent.distance.vec)
new.edges
# remember to use the un-pruned version of the stream map
EFLewis.surveys<-MakeSurveyTracks(shape = EFLewis.basin,surveys = surveys,surveys.crs = "wgs84",
survey.coords = c("ULon","ULat","LLon","LLat"))
EFLewis.basin
shape = EFLewis.basin
surveys
surveys.crs = "wgs84"
survey.coords = c("ULon","ULat","LLon","LLat")
if(class(shape)[1]=="sfnetwork"){
shape.net<-shape
shape.edges<-sf::st_as_sf(sfnetworks::activate(shape,"edges"))
}else{
shape.net<-Makesfnetwork(shape,attach.data=F)
shape.edges<-shape
}
if(save.col[1]=="all"){
save.col<-names(surveys)[names(surveys)%in%survey.coords==F]
}
# need to turn the surveys in line objects
shape.union<-sf::st_geometry(shape)
save.col<-names(surveys)[names(surveys)%in%survey.coords==F]
# need to turn the surveys in line objects
shape.union<-sf::st_geometry(shape)
if(nrow(shape)>1 | any(sf::st_geometry_type(shape)=="MULTILINESTRING")){
shape.union<-sf::st_line_merge(sf::st_union(shape.edges))
}
shape
nrow(shape)
#' @param surveys A data frame with coordinates and any other desired information
#' @param surveys.crs a crs object or code for the survey coordinates
#' @param save.col character vector with names of any columns to save, or "all"
#' @param maxdist a maximum distance for when the coordinates are compared to the shape
#' @param survey.coords vector of names or column numbers; order matters
#'
#' @return A sf object with LINESTRINGS and data representing each survey
#' @export
#'
#' @examples
MakeSurveyTracks<-function(shape, surveys,surveys.crs="wgs84",save.col="all",
maxdist=25, survey.coords=c("startlon","startlat","endlon","endlat")){
if(class(shape)[1]=="sfnetwork"){
shape.net<-shape
shape.edges<-sf::st_as_sf(sfnetworks::activate(shape,"edges"))
}else{
shape.net<-Makesfnetwork(shape,attach.data=F)
shape.edges<-shape
}
if(save.col[1]=="all"){
save.col<-names(surveys)[names(surveys)%in%survey.coords==F]
}
# need to turn the surveys in line objects
shape.union<-sf::st_geometry(shape.edges)
if(nrow(shape.edges)>1 | any(sf::st_geometry_type(shape.edges)=="MULTILINESTRING")){
shape.union<-sf::st_line_merge(sf::st_union(shape.edges))
}
if(sf::st_geometry_type(shape.union)=="MULTILINESTRING"){
shape.union<-sf::st_cast(shape.union,"LINESTRING")
}
start.points0<-sf::st_as_sf(surveys,coords=survey.coords[1:2],crs=surveys.crs)
start.points<-sf::st_transform(start.points0,crs=sf::st_crs(shape))
end.points0<-sf::st_as_sf(surveys,coords=survey.coords[3:4],crs=surveys.crs)
end.points<-sf::st_transform(end.points0,crs=sf::st_crs(shape))
# Setup the output objects
out.shape<-sf::st_as_sf(shape.union[0])
sf::st_geometry(out.shape)<-"geometry"
good.surveys<-NULL
bad.coords<-NULL
# loop through and make a feature collection of the survey lines
pb<-utils::txtProgressBar(min = 0, max = nrow(start.points), initial = 0, style=3)
for(i in 1:nrow(start.points)){
test.point<-rbind(start.points[i,"geometry"],end.points[i,"geometry"])
# first check that its on the network
test.dists<-c(min(sf::st_distance(test.point[1,],shape.union)),
min(sf::st_distance(test.point[2,],shape.union)))
# now structured so that if either point is out of area, discard it
if(all(as.numeric(test.dists)<=maxdist)){
start<-NA
end<-NA
# snap the points to the network, the careful way
nearest1<-sf::st_nearest_points(test.point[1,],shape.union)
pt1<-nearest1[which.min(sf::st_length(nearest1))]
if(as.numeric(sf::st_length(pt1))<=maxdist){
start<-sf::st_as_sf(as.data.frame(sf::st_coordinates(pt1))[2,1:2],coords=1:2,
crs=sf::st_crs(shape.union))
start.seg<-shape.union[which.min(sf::st_length(nearest1))]
}
nearest2<-sf::st_nearest_points(test.point[2,],shape.union)
pt2<-nearest2[which.min(sf::st_length(nearest2))]
if(as.numeric(sf::st_length(pt2))<=maxdist){
end<-sf::st_as_sf(as.data.frame(sf::st_coordinates(pt2))[2,1:2],coords=1:2,
crs=sf::st_crs(shape.union))
end.seg<-shape.union[which.min(sf::st_length(nearest2))]
}
# check for that very annoying rounding error
start.ok<-sf::st_intersects(start,start.seg,sparse = F)[1,1]
end.ok<-sf::st_intersects(end,end.seg,sparse = F)[1,1]
# if present, fix it the error
start2<-start
end2<-end
if(!start.ok){
start.seg.points<-sf::st_cast(start.seg,"POINT")
start.dists<-sf::st_distance(start,start.seg.points)
if(as.numeric(min(start.dists))<=maxdist){
start2<-start.seg.points[which.min(start.dists)]
}else{
# its possible that the fixed point is further away than the desired tolerance
# in which case, we can resample the line segment to find a closer point
start.seg.points2<-sf::st_cast(sf::st_line_sample(start.seg,density=1/maxdist),"POINT")
start.dists2<-sf::st_distance(start,start.seg.points2)
start2<-start.seg.points2[which.min(start.dists2)]
}
}
if(!end.ok){
end.seg.points<-sf::st_cast(end.seg,"POINT")
end.dists<-sf::st_distance(end,end.seg.points)
if(as.numeric(min(end.dists))<=maxdist){
end2<-end.seg.points[which.min(end.dists)]
}else{
end.seg.points2<-sf::st_cast(sf::st_line_sample(end.seg,density=1/maxdist),"POINT")
end.dists2<-sf::st_distance(end,end.seg.points2)
end2<-end.seg.points2[which.min(end.dists2)]
}
}
# now that we are sure both points are exactly on the stream line, we can add them to the network
shape.net2<-sfnetworks::st_network_blend(x=shape.net,rbind(sf::st_as_sf(start2),sf::st_as_sf(end2)))
edge.path<-sfnetworks::st_network_paths(x=shape.net2,from=sf::st_as_sf(start),to=sf::st_as_sf(end),mode="all")
new.shape<-sf::st_as_sf(sfnetworks::activate(shape.net2,"edges"))[edge.path$edge_paths[[1]],]
if(nrow(new.shape)>0){
new.shape<-sf::st_as_sf(sf::st_line_merge(sf::st_combine(new.shape)))
sf::st_geometry(new.shape)<-"geometry"
out.shape<-rbind(out.shape,new.shape)
good.surveys<-c(good.surveys,i)
}else{
bad.coords<-c(bad.coords,i)
}
}
utils::setTxtProgressBar(pb,i)
}
close(pb)
if(length(bad.coords)>0){
print(paste0("Warning: Removed ",length(bad.coords), " surveys due to bad coordinates!"))
print(paste0("Effected survey indices : ",paste(bad.coords,collapse = ", ")))
}
# Attach the other data and return
out.shape<-cbind(out.shape,surveys[good.surveys,save.col])
sf::st_geometry(out.shape)<-"geometry"
return(out.shape)
}
# remember to use the un-pruned version of the stream map
EFLewis.surveys<-MakeSurveyTracks(shape = EFLewis.basin,surveys = surveys,surveys.crs = "wgs84",
survey.coords = c("ULon","ULat","LLon","LLat"))
EFLewis.surveys
shape = EFLewis.reaches3
georedds = observed.redds
reddcrs = "wgs84"
surveys = EFLewis.surveys
georedds.type = "redd_status_code"
tolerance.redds=250
tolerance.surveys=10
survey.redds=NA
if(class(shape)[1]=="sfnetwork"){
shape.edges<-sf::st_as_sf(sfnetworks::activate(shape,"edges"))
}else(
shape.edges<-shape
)
#remove some surveys
if(is.na(survey.redds)==F){
good.surveys<-surveys[is.na(as.data.frame(surveys)[,survey.redds])==F,]
}else{
good.surveys<-surveys
}
good.surveys$tempID<-1:nrow(good.surveys)
# some setup
surveys.dat<-as.data.frame(good.surveys)
day.col<-which(tolower(names(surveys.dat))=="day")
year.col<-which(tolower(names(surveys.dat))=="year")
# There are a lot of potential ways to assign non-georeferenced redds, but for now
# we will just assume even spacing along the survey line
# need to improve method of handling dates
print("Geo-locating Redds")
if(is.na(survey.redds)==F){
has.redds<-which(as.data.frame(good.surveys)[,survey.redds]>0)
pb<-utils::txtProgressBar(min = 0, max = length(has.redds), initial = 0, style=3)
for(i in 1:length(has.redds)){
active.survey<-good.surveys[has.redds[i],]
redds<-as.data.frame(active.survey)[,survey.redds]
redds.sf<-sf::st_as_sf(sf::st_cast(sf::st_line_sample(active.survey,
sample = (1:redds)/(redds+1)),"POINT"))
redds.sf$Year<-surveys.dat[has.redds[i],year.col]
redds.sf$Day<-surveys.dat[has.redds[i],day.col]
closest.reach<-shape.edges$reachid[sf::st_nearest_feature(x=redds.sf,shape.edges)]
closest.dists<-sf::st_distance(redds.sf,shape.edges[match(closest.reach,
shape.edges$reachid),],by_element = T)
redds.sf$closest<-closest.reach
redds.sf$tempID<-active.survey$tempID
if(i==1){
survey.redds.sf<-redds.sf[as.numeric(closest.dists)<=tolerance.redds,]
}else{
survey.redds.sf<-rbind(survey.redds.sf,redds.sf[as.numeric(closest.dists)<=tolerance.redds,])
}
utils::setTxtProgressBar(pb,i)
}
close(pb)
}else{
survey.redds.sf<-NULL
}
# Setup any georeferenced redds, should improve handling of dates so that it's not just assumed to be in
# correct format
if(is.data.frame(georedds)){
if(is.na(georedds.coords)[1]){
lon.col<-which(tolower(names(georedds))%in%c("longitude","lon","long","x"))[1]
lat.col<-which(tolower(names(georedds))%in%c("latitude","lat","y"))[1]
}else{
lon.col<-georedds.coords[1]
lat.col<-georedds.coords[2]
}
badrow<-which(is.na(georedds[,lon.col]) | is.na(georedds[,lat.col]))
if(length(badrow)>0){
georedds.sf<-sf::st_as_sf(georedds[-badrow,],coords=c(lon.col,lat.col),crs=reddcrs)
}else{
georedds.sf<-sf::st_as_sf(georedds,coords=c(lon.col,lat.col),crs=reddcrs)
}
georedds.sf2<-sf::st_transform(georedds.sf,crs=sf::st_crs(shape))
closest.reach<-shape.edges$reachid[sf::st_nearest_feature(x=georedds.sf2,shape.edges)]
closest.dists<-sf::st_distance(georedds.sf2,shape.edges[match(closest.reach,shape.edges$reachid),],by_element = T)
georedds.sf2$closest<-closest.reach
georedds.sf3<-georedds.sf2[which(as.integer(closest.dists)<=tolerance.redds),]
redd.day.col<-which(tolower(names(georedds.sf3))=="day")
redd.year.col<-which(tolower(names(georedds.sf3))=="year")
georedds.sf3$tempID<-NA
# need to match redds to surveys
pb<-utils::txtProgressBar(min = 0, max = nrow(georedds.sf3), initial = 0, style=3)
for(i in 1:nrow(georedds.sf3)){
good.surveys2<-good.surveys[surveys.dat[,year.col]==as.data.frame(georedds.sf3)[i,redd.year.col] &
surveys.dat[,day.col]==as.data.frame(georedds.sf3)[i,redd.day.col],]
survey.dists<-sf::st_length(sf::st_nearest_points(georedds.sf3[i,],good.surveys2))
georedds.sf3$tempID[i]<-good.surveys2$tempID[which.min(survey.dists)]
utils::setTxtProgressBar(pb,i)
}
close(pb)
}else{
georedds.sf3<-NULL
}
georedds.coords=NA
# Setup any georeferenced redds, should improve handling of dates so that it's not just assumed to be in
# correct format
if(is.data.frame(georedds)){
if(is.na(georedds.coords)[1]){
lon.col<-which(tolower(names(georedds))%in%c("longitude","lon","long","x"))[1]
lat.col<-which(tolower(names(georedds))%in%c("latitude","lat","y"))[1]
}else{
lon.col<-georedds.coords[1]
lat.col<-georedds.coords[2]
}
badrow<-which(is.na(georedds[,lon.col]) | is.na(georedds[,lat.col]))
if(length(badrow)>0){
georedds.sf<-sf::st_as_sf(georedds[-badrow,],coords=c(lon.col,lat.col),crs=reddcrs)
}else{
georedds.sf<-sf::st_as_sf(georedds,coords=c(lon.col,lat.col),crs=reddcrs)
}
georedds.sf2<-sf::st_transform(georedds.sf,crs=sf::st_crs(shape))
closest.reach<-shape.edges$reachid[sf::st_nearest_feature(x=georedds.sf2,shape.edges)]
closest.dists<-sf::st_distance(georedds.sf2,shape.edges[match(closest.reach,shape.edges$reachid),],by_element = T)
georedds.sf2$closest<-closest.reach
georedds.sf3<-georedds.sf2[which(as.integer(closest.dists)<=tolerance.redds),]
redd.day.col<-which(tolower(names(georedds.sf3))=="day")
redd.year.col<-which(tolower(names(georedds.sf3))=="year")
georedds.sf3$tempID<-NA
# need to match redds to surveys
pb<-utils::txtProgressBar(min = 0, max = nrow(georedds.sf3), initial = 0, style=3)
for(i in 1:nrow(georedds.sf3)){
good.surveys2<-good.surveys[surveys.dat[,year.col]==as.data.frame(georedds.sf3)[i,redd.year.col] &
surveys.dat[,day.col]==as.data.frame(georedds.sf3)[i,redd.day.col],]
survey.dists<-sf::st_length(sf::st_nearest_points(georedds.sf3[i,],good.surveys2))
georedds.sf3$tempID[i]<-good.surveys2$tempID[which.min(survey.dists)]
utils::setTxtProgressBar(pb,i)
}
close(pb)
}else{
georedds.sf3<-NULL
}
good.redds<-rbind(survey.redds.sf,georedds.sf3)
pb<-utils::txtProgressBar(min = 0, max = nrow(good.surveys), initial = 0, style=3)
print("Resolving Survey Effort & assigning Redds")
first.iter<-T
for(i in 1:nrow(good.surveys)){
overlapping<-which(sf::st_intersects(good.surveys[i,],shape.edges,sparse=F))
if(length(overlapping)>0){
for(j in 1:length(overlapping)){
# because of imperfect snapping, we're going to do this the harder way
# check which points are within the distance, and assume all inbetween points
# ought to be included, even if the tracks are slightly off
reach.shape<-shape.edges[overlapping[j],]
reach.points<-suppressWarnings(sf::st_cast(reach.shape,"POINT"))
good.points<-which(as.numeric(sf::st_length(sf::st_nearest_points(reach.points,good.surveys[i,])))<tolerance.surveys)
# assume that any gaps are an error in snapping the shapes together
# might cause problems if we ever start working with multi-channel streams, but ok for now
line.points<-min(good.points):max(good.points)
reach.intersection<-sf::st_cast(sf::st_combine(reach.points[line.points,]),"LINESTRING")
intersection.length<-sf::st_length(reach.intersection)
# drop very small intersections,
if(as.numeric(intersection.length/sf::st_length(reach.shape))>.02){
out.dat<-data.frame(Year=surveys.dat[i,year.col],
Day=surveys.dat[i,day.col],
Reach=overlapping[j],
Effort=intersection.length)
active.redds<-good.redds[good.redds$closest==overlapping[j] &
good.redds$tempID==good.surveys$tempID[i],]
if(is.na(georedds.type)){
Redd.counts<-data.frame(Redds=nrow(active.redds))
redd.codes<-NA
}else{
redd.codes<-unique(as.data.frame(good.redds)[,georedds.type])
Redd.counts<-as.data.frame(matrix(nrow=1,ncol=length(redd.codes),data=0))
names(Redd.counts)<-paste("Redds",redd.codes,sep="_")
for(t in 1:length(redd.codes)){
Redd.counts[1,t]<-length(which(as.data.frame(active.redds)[,georedds.type]==redd.codes[t]))
}
}
if(first.iter){
out.data<-cbind(out.dat,Redd.counts)
first.iter<-F
}else{
out.data<-rbind(out.data,cbind(out.dat,Redd.counts))
}
}
}
}
utils::setTxtProgressBar(pb,i)
}
close(pb)
# Need to fix cases where the same reach is covered partially by two surveys
# in future, may wish to preserve this difference, would require attaching a survey id to the data
# Will need updating when it is time to work with surveys that don't have georeferenced redds
doubles<-names(which(table(paste(out.data$Year,out.data$Day,out.data$Reach,sep="_"))>1))
for(i in 1:length(doubles)){
y<-strsplit(doubles[i],split="_")[[1]][1]
d<-strsplit(doubles[i],split="_")[[1]][2]
r<-strsplit(doubles[i],split="_")[[1]][3]
d.rows<-which(out.data$Year==y & out.data$Day==d & out.data$Reach==r)
d.data<-out.data[d.rows,]
new.data<-data.frame(Year=as.integer(y),Day=as.integer(d),Reach=as.integer(r),
Effort=sum(d.data$Effort))
if(length(redd.codes)==1){new.redds<-data.frame(Redds=sum(d.data$redds))}
if(length(redd.codes)>1){new.redds<-t(as.data.frame(apply(d.data[,-(1:4)],MARGIN=2,FUN=sum)))}
out.data<-rbind(out.data[-d.rows,],cbind(new.data,new.redds))
}
# carry over any covariates
var.col<-names(shape.edges)[names(shape.edges)%in%c("from","to","reachid","geometry")==F]
reach.match<-match(out.data$Reach,shape.edges$reachid)
out.data<-cbind(out.data,as.data.frame(shape.edges)[reach.match,var.col])
rownames(out.data)<-NULL
out.data
# Read in some data
data.list<-LoadStreamData(watershed = "East_Fork_Lewis",size = 2000)
Redd.data
data.list[[1]]
out.data
str(out.data)
is.data.frame(out.data)
class(out.data)
devtools::document()
devtools::document(pkg = "StreamVAST")
warnings()
usethis::use_pkgdown()
pkgdown::build_site()
usethis::use_pkgdown_github_pages()
usethis::use_pkgdown_github_pages()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::deploy_to_branch()
# check that _pkgdown.yml looks good
pkgdown::check_pkgdown()
#-----------------------------------------------------------------
# load needed libraries
library(pkgdown)
#-----------------------------------------------------------------
# set up to automatically publish pkgdown site to GitHub
usethis::use_pkgdown_github_pages()
# Run once to configure your package to use pkgdown
usethis::use_pkgdown()
# check that _pkgdown.yml looks good
pkgdown::check_pkgdown()
# Run to build the website
pkgdown::build_site()
#-----------------------------------------------------------------
# deploy site to gh-pages branch on GitHub
pkgdown::deploy_to_branch()
---
title: "Preparing a Stream Network"
library(StreamVAST)
library(sf)
library(ggplot2)
library(sfnetworks)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(StreamVAST)
library(sf)
library(ggplot2)
library(sfnetworks)
library(StreamVAST)
library(sf)
library(ggplot2)
library(sfnetworks)
# StreamVAST
StreamVAST is an R package designed to help users format data from freshwater stream networks and interface with the VAST package to produce spatio-temporal models of animal densities. This package contains a variety of useful functions for quickly processing complex stream networks into a usable form, and attaching a variety of data to this network. It makes extensive use of the sfnetworks package, and users are advised to familiarize themselves with the basics of [sfnetworks](https://cran.r-project.org/web/packages/sfnetworks/vignettes/sfn01_structure.html), particularly regarding activation and extraction of data. This chapter covers the steps necessary to prepare stream shapes and associated data. A  second chapter will demonstrate how this data can then be used to create spatio-temporal models using VAST.
## Example: Steelhead Salmon Redds in Mill Creek
Mill Creek is a small watershed located east of Longview, Washington that is home to an annual winter steelhead run from February to June. The population is assessed via counting the number of "redds" or nests observed during regular surveys during this spawning season. Redds are recorded using GPS devices and are tracked during successive surveys to determine if a particular is new or has been observed previously.
```{r include=FALSE}
Mill.basin0<-st_read(dsn = "Mill_Creek_basin_raw.shp")
Mill.redds.sf<-st_read(dsn="Mill_Creek_redds_example.shp")
Mill.redds<-data.frame(as.data.frame(Mill.redds.sf),lon=st_coordinates(Mill.redds.sf)[,1],lat=st_coordinates(Mill.redds.sf)[,2])
Mill.basin<-as_sfnetwork(Mill.basin0)
Mill.surveys<-st_read(dsn="Mill_Creek_surveys_example.shp")
ggplot()+geom_sf(data=Mill.basin0)+theme_bw()+ggtitle("Mill Creek Basin")+scale_x_continuous(breaks=c(-123.28,-123.20),limits = st_bbox(Mill.basin0)[c(1,3)])
Mill.net<-Makesfnetwork(Mill.basin0)
Mill.root<-LocateRoot(Mill.net)
Mill.net.edges<-st_as_sf(activate(Mill.net,"edges"))
Mill.net.edges$loop<-F
Mill.net.edges$loop[loops]<-T
loops<-NULL
for(i in 1:nrow(Mill.net.edges)){
seg<-Mill.net.edges[i,]
others<-Mill.net.edges[-i,]
picks<-which(seg$from==others$from & seg$to==others$to)
if(length(picks>0)){loops<-c(loops,i)}
}
Mill.net.edges$loop<-F
Mill.net.edges$loop[loops]<-T
ggplot()+
geom_sf(data=Mill.net.edges,aes(col=loop))+scale_color_manual(values=c(1,2),guide="none")+
geom_sf(data=Mill.root,col=2,shape=18,size=3)+theme_bw()+
scale_x_continuous(breaks = c(-123.22,-123.20,-123.18),limits=c(951567,964249))+
scale_y_continuous(breaks=c(46.19,46.2,46.21,46.22),limits=c(321626,334686))
Mill.net.edges2<-Mill.net.edges[-108,]
Mill.basin<-as_sfnetwork(Mill.net.edges2)
print(Mill.basin,0)
Mill.basin2<-PruneNetwork(network = Mill.basin, root = Mill.root,match = Mill.redds.sf,plot=F)
Mill.basin2.edges<-st_as_sf(activate(Mill.basin2,"edges"))
Mill.basin3<-SimplifyNetwork(network = Mill.basin2,makeplot = F)
Mill.reaches<-AssignReaches(network = Mill.basin3,targetsize = 3280)
Mill.reaches2<-AttachData(shape = st_as_sf(activate(Mill.reaches,"edges")),refshape = Mill.basin0,fields = "STRM_NAME")
Mill.reaches3<-CheckNetwork(network=as_sfnetwork(Mill.reaches2),root=Mill.root)
Mill.data<-AssembleReddData(shape = Mill.reaches3,georedds = Mill.redds,georedds.coords = c("lon","lat"),reddcrs = 2286,surveys = Mill.surveys)
write.csv(Mill.data,file = "Mill_data.csv")
Mill.reaches3
st_write(st_as_sf(activate(Mill.reaches3,"edges")),"Mill_reaches.shp")
st_write(Mill.surveys,"Mill_survey_tracks.shp")
library(StreamVAST)
library(sf)
library(ggplot2)
library(sfnetworks)
Mill.data<-read.csv("Mill_data.csv")
Mill.reaches<-st_read("Mill_reaches.shp")
Mill.surveys<-st_read("Mill_survey_tracks.shp")
print(Mill.reaches,6)
print(Mill.reaches,4)
print(Mill.reaches,n = 4)
head(Mill.data)
?FormatStreamData
?LoadStreamData
remotes::install_github("Jpharris7/StreamVAST")
