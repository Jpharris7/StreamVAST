root.index<-new.edges$from[which(new.edges$root)]
end.nodes<-new.edges$to[new.edges$to%in%new.edges$from==F]
#need to make a table that converts the old order to the new order, then we can grab values from old data frame
network.table<-data.frame(oldid=new.edges$reachid,newids=0)
costs<-sfnetworks::st_network_cost(x = new.network,from = root.index,to = end.nodes)
costs2<-sort(costs,decreasing=T)
end.nodes2<-end.nodes[order(costs,decreasing=T)]
for(i in 1:length(end.nodes2)){
start.val<-max(network.table$newids)+1
path<-sfnetworks::st_network_paths(x = new.network,from = root.index,to = end.nodes2[i])$node_paths[[1]]
path2<-path[path!=root.index]
match.vec<-match(path2,new.edges$to)
match.vec2<-match.vec[network.table$newids[match.vec]==0]
network.table$newids[match.vec2]<-start.val:(start.val+length(match.vec2)-1)
}
new.edges$reachid<-network.table$newid[match(new.edges$reachid,network.table$oldid)]
new.edges<-new.edges[order(new.edges$reachid),]
# now can compute the parents, though this is going to be complicated by habitat/nonhabitat
new.edges$parent<-new.edges$reachid[match(new.edges$from,new.edges$to)]
new.parent.vec<-rep(NA,nrow(new.edges))
parent.distance.vec<-rep(NA,nrow(new.edges))
# now account for habitat
for(i in 1:nrow(new.edges)){
if(new.edges$root[i]==F){
parent<-new.edges$parent[i]
# if the parent is habitat, things are easy
if(new.edges$habitat[parent]){
new.parent.vec[i]<-parent
parent.distance.vec[i]<-.5*sf::st_length(new.edges)[i]+.5*sf::st_length(new.edges)[parent]
}else{
# loop through to parent is easier than converting to network
bad.parent<-T
path.segs<-parent
active.seg<-parent
while(bad.parent){
new.parent<-new.edges$parent[active.seg]
if(new.edges$habitat[new.parent]){
bad.parent<-F
}else{
path.segs<-c(path.segs,new.parent)
active.seg<-new.parent
}
}
new.parent.vec[i]<-new.parent
parent.distance.vec[i]<-.5*sf::st_length(new.edges)[i]+.5*sf::st_length(new.edges)[new.parent]+
sf::st_length(new.edges)[path.segs]
}
}
}
new.edges
new.edges$parent<-new.parent.vec
new.edges$parent.distance<-parent.distance.vec
new.edges
new.parent.vec
parent.distance.vec
i=6
# now can compute the parents, though this is going to be complicated by habitat/nonhabitat
new.edges$parent<-new.edges$reachid[match(new.edges$from,new.edges$to)]
parent<-new.edges$parent[i]
parent
new.edges$habitat[parent]
# loop through to parent is easier than converting to network
bad.parent<-T
path.segs<-parent
active.seg<-parent
path.segs
while(bad.parent){
new.parent<-new.edges$parent[active.seg]
if(new.edges$habitat[new.parent]){
bad.parent<-F
}else{
path.segs<-c(path.segs,new.parent)
active.seg<-new.parent
}
}
path.segs
new.parent
.5*sf::st_length(new.edges)[i]+.5*sf::st_length(new.edges)[new.parent]+
sf::st_length(new.edges)[path.segs]
network.edges<-sf::st_as_sf(sfnetworks::activate(network,"edges"))
root.sf<-PointSetup(point = root,crs = sf::st_crs(network))
# first, check that all stream segments are going the right direction
root.node.index<-sf::st_nearest_feature(root.sf,sf::st_as_sf(sfnetworks::activate(network,"nodes")))
root.distances<-as.vector(sfnetworks::st_network_cost(network,root.node.index,direction="all"))
reversed<-which(root.distances[network.edges$from]>root.distances[network.edges$to])
old.network.edges<-network.edges
if(length(reversed>0)){
old.network.edges$from[reversed]<-network.edges$to[reversed]
old.network.edges$to[reversed]<-network.edges$from[reversed]
}
# assign the root
old.network.edges$root<-old.network.edges$from==root.node.index
#Now, let renumber the reachids so that they procede in an easy to interpret order
new.network<-sfnetworks::as_sfnetwork(old.network.edges)
new.edges<-sf::st_as_sf(sfnetworks::activate(new.network,"edges"))
new.nodes<-sf::st_as_sf(sfnetworks::activate(new.network,"nodes"))
root.index<-new.edges$from[which(new.edges$root)]
end.nodes<-new.edges$to[new.edges$to%in%new.edges$from==F]
#need to make a table that converts the old order to the new order, then we can grab values from old data frame
network.table<-data.frame(oldid=new.edges$reachid,newids=0)
costs<-sfnetworks::st_network_cost(x = new.network,from = root.index,to = end.nodes)
costs2<-sort(costs,decreasing=T)
end.nodes2<-end.nodes[order(costs,decreasing=T)]
for(i in 1:length(end.nodes2)){
start.val<-max(network.table$newids)+1
path<-sfnetworks::st_network_paths(x = new.network,from = root.index,to = end.nodes2[i])$node_paths[[1]]
path2<-path[path!=root.index]
match.vec<-match(path2,new.edges$to)
match.vec2<-match.vec[network.table$newids[match.vec]==0]
network.table$newids[match.vec2]<-start.val:(start.val+length(match.vec2)-1)
}
new.edges$reachid<-network.table$newid[match(new.edges$reachid,network.table$oldid)]
new.edges<-new.edges[order(new.edges$reachid),]
# now can compute the parents, though this is going to be complicated by habitat/nonhabitat
new.edges$parent<-new.edges$reachid[match(new.edges$from,new.edges$to)]
new.parent.vec<-rep(NA,nrow(new.edges))
parent.distance.vec<-rep(NA,nrow(new.edges))
# now account for habitat
for(i in 1:nrow(new.edges)){
if(new.edges$root[i]==F){
parent<-new.edges$parent[i]
# if the parent is habitat, things are easy
if(new.edges$habitat[parent]){
new.parent.vec[i]<-parent
parent.distance.vec[i]<-.5*sf::st_length(new.edges)[i]+.5*sf::st_length(new.edges)[parent]
}else{
# loop through to parent is easier than converting to network
bad.parent<-T
path.segs<-parent
active.seg<-parent
while(bad.parent){
new.parent<-new.edges$parent[active.seg]
if(new.edges$habitat[new.parent]){
bad.parent<-F
}else{
path.segs<-c(path.segs,new.parent)
active.seg<-new.parent
}
}
new.parent.vec[i]<-new.parent
parent.distance.vec[i]<-.5*sf::st_length(new.edges)[i]+.5*sf::st_length(new.edges)[new.parent]+
sum(sf::st_length(new.edges)[path.segs])
}
}
}
new.edges$parent<-new.parent.vec
new.edges$parent.distance<-as.numeric(parent.distance.vec)
new.edges
# remember to use the un-pruned version of the stream map
EFLewis.surveys<-MakeSurveyTracks(shape = EFLewis.basin,surveys = surveys,surveys.crs = "wgs84",
survey.coords = c("ULon","ULat","LLon","LLat"))
EFLewis.basin
shape = EFLewis.basin
surveys
surveys.crs = "wgs84"
survey.coords = c("ULon","ULat","LLon","LLat")
if(class(shape)[1]=="sfnetwork"){
shape.net<-shape
shape.edges<-sf::st_as_sf(sfnetworks::activate(shape,"edges"))
}else{
shape.net<-Makesfnetwork(shape,attach.data=F)
shape.edges<-shape
}
if(save.col[1]=="all"){
save.col<-names(surveys)[names(surveys)%in%survey.coords==F]
}
# need to turn the surveys in line objects
shape.union<-sf::st_geometry(shape)
save.col<-names(surveys)[names(surveys)%in%survey.coords==F]
# need to turn the surveys in line objects
shape.union<-sf::st_geometry(shape)
if(nrow(shape)>1 | any(sf::st_geometry_type(shape)=="MULTILINESTRING")){
shape.union<-sf::st_line_merge(sf::st_union(shape.edges))
}
shape
nrow(shape)
#' @param surveys A data frame with coordinates and any other desired information
#' @param surveys.crs a crs object or code for the survey coordinates
#' @param save.col character vector with names of any columns to save, or "all"
#' @param maxdist a maximum distance for when the coordinates are compared to the shape
#' @param survey.coords vector of names or column numbers; order matters
#'
#' @return A sf object with LINESTRINGS and data representing each survey
#' @export
#'
#' @examples
MakeSurveyTracks<-function(shape, surveys,surveys.crs="wgs84",save.col="all",
maxdist=25, survey.coords=c("startlon","startlat","endlon","endlat")){
if(class(shape)[1]=="sfnetwork"){
shape.net<-shape
shape.edges<-sf::st_as_sf(sfnetworks::activate(shape,"edges"))
}else{
shape.net<-Makesfnetwork(shape,attach.data=F)
shape.edges<-shape
}
if(save.col[1]=="all"){
save.col<-names(surveys)[names(surveys)%in%survey.coords==F]
}
# need to turn the surveys in line objects
shape.union<-sf::st_geometry(shape.edges)
if(nrow(shape.edges)>1 | any(sf::st_geometry_type(shape.edges)=="MULTILINESTRING")){
shape.union<-sf::st_line_merge(sf::st_union(shape.edges))
}
if(sf::st_geometry_type(shape.union)=="MULTILINESTRING"){
shape.union<-sf::st_cast(shape.union,"LINESTRING")
}
start.points0<-sf::st_as_sf(surveys,coords=survey.coords[1:2],crs=surveys.crs)
start.points<-sf::st_transform(start.points0,crs=sf::st_crs(shape))
end.points0<-sf::st_as_sf(surveys,coords=survey.coords[3:4],crs=surveys.crs)
end.points<-sf::st_transform(end.points0,crs=sf::st_crs(shape))
# Setup the output objects
out.shape<-sf::st_as_sf(shape.union[0])
sf::st_geometry(out.shape)<-"geometry"
good.surveys<-NULL
bad.coords<-NULL
# loop through and make a feature collection of the survey lines
pb<-utils::txtProgressBar(min = 0, max = nrow(start.points), initial = 0, style=3)
for(i in 1:nrow(start.points)){
test.point<-rbind(start.points[i,"geometry"],end.points[i,"geometry"])
# first check that its on the network
test.dists<-c(min(sf::st_distance(test.point[1,],shape.union)),
min(sf::st_distance(test.point[2,],shape.union)))
# now structured so that if either point is out of area, discard it
if(all(as.numeric(test.dists)<=maxdist)){
start<-NA
end<-NA
# snap the points to the network, the careful way
nearest1<-sf::st_nearest_points(test.point[1,],shape.union)
pt1<-nearest1[which.min(sf::st_length(nearest1))]
if(as.numeric(sf::st_length(pt1))<=maxdist){
start<-sf::st_as_sf(as.data.frame(sf::st_coordinates(pt1))[2,1:2],coords=1:2,
crs=sf::st_crs(shape.union))
start.seg<-shape.union[which.min(sf::st_length(nearest1))]
}
nearest2<-sf::st_nearest_points(test.point[2,],shape.union)
pt2<-nearest2[which.min(sf::st_length(nearest2))]
if(as.numeric(sf::st_length(pt2))<=maxdist){
end<-sf::st_as_sf(as.data.frame(sf::st_coordinates(pt2))[2,1:2],coords=1:2,
crs=sf::st_crs(shape.union))
end.seg<-shape.union[which.min(sf::st_length(nearest2))]
}
# check for that very annoying rounding error
start.ok<-sf::st_intersects(start,start.seg,sparse = F)[1,1]
end.ok<-sf::st_intersects(end,end.seg,sparse = F)[1,1]
# if present, fix it the error
start2<-start
end2<-end
if(!start.ok){
start.seg.points<-sf::st_cast(start.seg,"POINT")
start.dists<-sf::st_distance(start,start.seg.points)
if(as.numeric(min(start.dists))<=maxdist){
start2<-start.seg.points[which.min(start.dists)]
}else{
# its possible that the fixed point is further away than the desired tolerance
# in which case, we can resample the line segment to find a closer point
start.seg.points2<-sf::st_cast(sf::st_line_sample(start.seg,density=1/maxdist),"POINT")
start.dists2<-sf::st_distance(start,start.seg.points2)
start2<-start.seg.points2[which.min(start.dists2)]
}
}
if(!end.ok){
end.seg.points<-sf::st_cast(end.seg,"POINT")
end.dists<-sf::st_distance(end,end.seg.points)
if(as.numeric(min(end.dists))<=maxdist){
end2<-end.seg.points[which.min(end.dists)]
}else{
end.seg.points2<-sf::st_cast(sf::st_line_sample(end.seg,density=1/maxdist),"POINT")
end.dists2<-sf::st_distance(end,end.seg.points2)
end2<-end.seg.points2[which.min(end.dists2)]
}
}
# now that we are sure both points are exactly on the stream line, we can add them to the network
shape.net2<-sfnetworks::st_network_blend(x=shape.net,rbind(sf::st_as_sf(start2),sf::st_as_sf(end2)))
edge.path<-sfnetworks::st_network_paths(x=shape.net2,from=sf::st_as_sf(start),to=sf::st_as_sf(end),mode="all")
new.shape<-sf::st_as_sf(sfnetworks::activate(shape.net2,"edges"))[edge.path$edge_paths[[1]],]
if(nrow(new.shape)>0){
new.shape<-sf::st_as_sf(sf::st_line_merge(sf::st_combine(new.shape)))
sf::st_geometry(new.shape)<-"geometry"
out.shape<-rbind(out.shape,new.shape)
good.surveys<-c(good.surveys,i)
}else{
bad.coords<-c(bad.coords,i)
}
}
utils::setTxtProgressBar(pb,i)
}
close(pb)
if(length(bad.coords)>0){
print(paste0("Warning: Removed ",length(bad.coords), " surveys due to bad coordinates!"))
print(paste0("Effected survey indices : ",paste(bad.coords,collapse = ", ")))
}
# Attach the other data and return
out.shape<-cbind(out.shape,surveys[good.surveys,save.col])
sf::st_geometry(out.shape)<-"geometry"
return(out.shape)
}
# remember to use the un-pruned version of the stream map
EFLewis.surveys<-MakeSurveyTracks(shape = EFLewis.basin,surveys = surveys,surveys.crs = "wgs84",
survey.coords = c("ULon","ULat","LLon","LLat"))
EFLewis.surveys
shape = EFLewis.reaches3
georedds = observed.redds
reddcrs = "wgs84"
surveys = EFLewis.surveys
georedds.type = "redd_status_code"
tolerance.redds=250
tolerance.surveys=10
survey.redds=NA
if(class(shape)[1]=="sfnetwork"){
shape.edges<-sf::st_as_sf(sfnetworks::activate(shape,"edges"))
}else(
shape.edges<-shape
)
#remove some surveys
if(is.na(survey.redds)==F){
good.surveys<-surveys[is.na(as.data.frame(surveys)[,survey.redds])==F,]
}else{
good.surveys<-surveys
}
good.surveys$tempID<-1:nrow(good.surveys)
# some setup
surveys.dat<-as.data.frame(good.surveys)
day.col<-which(tolower(names(surveys.dat))=="day")
year.col<-which(tolower(names(surveys.dat))=="year")
# There are a lot of potential ways to assign non-georeferenced redds, but for now
# we will just assume even spacing along the survey line
# need to improve method of handling dates
print("Geo-locating Redds")
if(is.na(survey.redds)==F){
has.redds<-which(as.data.frame(good.surveys)[,survey.redds]>0)
pb<-utils::txtProgressBar(min = 0, max = length(has.redds), initial = 0, style=3)
for(i in 1:length(has.redds)){
active.survey<-good.surveys[has.redds[i],]
redds<-as.data.frame(active.survey)[,survey.redds]
redds.sf<-sf::st_as_sf(sf::st_cast(sf::st_line_sample(active.survey,
sample = (1:redds)/(redds+1)),"POINT"))
redds.sf$Year<-surveys.dat[has.redds[i],year.col]
redds.sf$Day<-surveys.dat[has.redds[i],day.col]
closest.reach<-shape.edges$reachid[sf::st_nearest_feature(x=redds.sf,shape.edges)]
closest.dists<-sf::st_distance(redds.sf,shape.edges[match(closest.reach,
shape.edges$reachid),],by_element = T)
redds.sf$closest<-closest.reach
redds.sf$tempID<-active.survey$tempID
if(i==1){
survey.redds.sf<-redds.sf[as.numeric(closest.dists)<=tolerance.redds,]
}else{
survey.redds.sf<-rbind(survey.redds.sf,redds.sf[as.numeric(closest.dists)<=tolerance.redds,])
}
utils::setTxtProgressBar(pb,i)
}
close(pb)
}else{
survey.redds.sf<-NULL
}
# Setup any georeferenced redds, should improve handling of dates so that it's not just assumed to be in
# correct format
if(is.data.frame(georedds)){
if(is.na(georedds.coords)[1]){
lon.col<-which(tolower(names(georedds))%in%c("longitude","lon","long","x"))[1]
lat.col<-which(tolower(names(georedds))%in%c("latitude","lat","y"))[1]
}else{
lon.col<-georedds.coords[1]
lat.col<-georedds.coords[2]
}
badrow<-which(is.na(georedds[,lon.col]) | is.na(georedds[,lat.col]))
if(length(badrow)>0){
georedds.sf<-sf::st_as_sf(georedds[-badrow,],coords=c(lon.col,lat.col),crs=reddcrs)
}else{
georedds.sf<-sf::st_as_sf(georedds,coords=c(lon.col,lat.col),crs=reddcrs)
}
georedds.sf2<-sf::st_transform(georedds.sf,crs=sf::st_crs(shape))
closest.reach<-shape.edges$reachid[sf::st_nearest_feature(x=georedds.sf2,shape.edges)]
closest.dists<-sf::st_distance(georedds.sf2,shape.edges[match(closest.reach,shape.edges$reachid),],by_element = T)
georedds.sf2$closest<-closest.reach
georedds.sf3<-georedds.sf2[which(as.integer(closest.dists)<=tolerance.redds),]
redd.day.col<-which(tolower(names(georedds.sf3))=="day")
redd.year.col<-which(tolower(names(georedds.sf3))=="year")
georedds.sf3$tempID<-NA
# need to match redds to surveys
pb<-utils::txtProgressBar(min = 0, max = nrow(georedds.sf3), initial = 0, style=3)
for(i in 1:nrow(georedds.sf3)){
good.surveys2<-good.surveys[surveys.dat[,year.col]==as.data.frame(georedds.sf3)[i,redd.year.col] &
surveys.dat[,day.col]==as.data.frame(georedds.sf3)[i,redd.day.col],]
survey.dists<-sf::st_length(sf::st_nearest_points(georedds.sf3[i,],good.surveys2))
georedds.sf3$tempID[i]<-good.surveys2$tempID[which.min(survey.dists)]
utils::setTxtProgressBar(pb,i)
}
close(pb)
}else{
georedds.sf3<-NULL
}
georedds.coords=NA
# Setup any georeferenced redds, should improve handling of dates so that it's not just assumed to be in
# correct format
if(is.data.frame(georedds)){
if(is.na(georedds.coords)[1]){
lon.col<-which(tolower(names(georedds))%in%c("longitude","lon","long","x"))[1]
lat.col<-which(tolower(names(georedds))%in%c("latitude","lat","y"))[1]
}else{
lon.col<-georedds.coords[1]
lat.col<-georedds.coords[2]
}
badrow<-which(is.na(georedds[,lon.col]) | is.na(georedds[,lat.col]))
if(length(badrow)>0){
georedds.sf<-sf::st_as_sf(georedds[-badrow,],coords=c(lon.col,lat.col),crs=reddcrs)
}else{
georedds.sf<-sf::st_as_sf(georedds,coords=c(lon.col,lat.col),crs=reddcrs)
}
georedds.sf2<-sf::st_transform(georedds.sf,crs=sf::st_crs(shape))
closest.reach<-shape.edges$reachid[sf::st_nearest_feature(x=georedds.sf2,shape.edges)]
closest.dists<-sf::st_distance(georedds.sf2,shape.edges[match(closest.reach,shape.edges$reachid),],by_element = T)
georedds.sf2$closest<-closest.reach
georedds.sf3<-georedds.sf2[which(as.integer(closest.dists)<=tolerance.redds),]
redd.day.col<-which(tolower(names(georedds.sf3))=="day")
redd.year.col<-which(tolower(names(georedds.sf3))=="year")
georedds.sf3$tempID<-NA
# need to match redds to surveys
pb<-utils::txtProgressBar(min = 0, max = nrow(georedds.sf3), initial = 0, style=3)
for(i in 1:nrow(georedds.sf3)){
good.surveys2<-good.surveys[surveys.dat[,year.col]==as.data.frame(georedds.sf3)[i,redd.year.col] &
surveys.dat[,day.col]==as.data.frame(georedds.sf3)[i,redd.day.col],]
survey.dists<-sf::st_length(sf::st_nearest_points(georedds.sf3[i,],good.surveys2))
georedds.sf3$tempID[i]<-good.surveys2$tempID[which.min(survey.dists)]
utils::setTxtProgressBar(pb,i)
}
close(pb)
}else{
georedds.sf3<-NULL
}
good.redds<-rbind(survey.redds.sf,georedds.sf3)
pb<-utils::txtProgressBar(min = 0, max = nrow(good.surveys), initial = 0, style=3)
print("Resolving Survey Effort & assigning Redds")
first.iter<-T
for(i in 1:nrow(good.surveys)){
overlapping<-which(sf::st_intersects(good.surveys[i,],shape.edges,sparse=F))
if(length(overlapping)>0){
for(j in 1:length(overlapping)){
# because of imperfect snapping, we're going to do this the harder way
# check which points are within the distance, and assume all inbetween points
# ought to be included, even if the tracks are slightly off
reach.shape<-shape.edges[overlapping[j],]
reach.points<-suppressWarnings(sf::st_cast(reach.shape,"POINT"))
good.points<-which(as.numeric(sf::st_length(sf::st_nearest_points(reach.points,good.surveys[i,])))<tolerance.surveys)
# assume that any gaps are an error in snapping the shapes together
# might cause problems if we ever start working with multi-channel streams, but ok for now
line.points<-min(good.points):max(good.points)
reach.intersection<-sf::st_cast(sf::st_combine(reach.points[line.points,]),"LINESTRING")
intersection.length<-sf::st_length(reach.intersection)
# drop very small intersections,
if(as.numeric(intersection.length/sf::st_length(reach.shape))>.02){
out.dat<-data.frame(Year=surveys.dat[i,year.col],
Day=surveys.dat[i,day.col],
Reach=overlapping[j],
Effort=intersection.length)
active.redds<-good.redds[good.redds$closest==overlapping[j] &
good.redds$tempID==good.surveys$tempID[i],]
if(is.na(georedds.type)){
Redd.counts<-data.frame(Redds=nrow(active.redds))
redd.codes<-NA
}else{
redd.codes<-unique(as.data.frame(good.redds)[,georedds.type])
Redd.counts<-as.data.frame(matrix(nrow=1,ncol=length(redd.codes),data=0))
names(Redd.counts)<-paste("Redds",redd.codes,sep="_")
for(t in 1:length(redd.codes)){
Redd.counts[1,t]<-length(which(as.data.frame(active.redds)[,georedds.type]==redd.codes[t]))
}
}
if(first.iter){
out.data<-cbind(out.dat,Redd.counts)
first.iter<-F
}else{
out.data<-rbind(out.data,cbind(out.dat,Redd.counts))
}
}
}
}
utils::setTxtProgressBar(pb,i)
}
close(pb)
# Need to fix cases where the same reach is covered partially by two surveys
# in future, may wish to preserve this difference, would require attaching a survey id to the data
# Will need updating when it is time to work with surveys that don't have georeferenced redds
doubles<-names(which(table(paste(out.data$Year,out.data$Day,out.data$Reach,sep="_"))>1))
for(i in 1:length(doubles)){
y<-strsplit(doubles[i],split="_")[[1]][1]
d<-strsplit(doubles[i],split="_")[[1]][2]
r<-strsplit(doubles[i],split="_")[[1]][3]
d.rows<-which(out.data$Year==y & out.data$Day==d & out.data$Reach==r)
d.data<-out.data[d.rows,]
new.data<-data.frame(Year=as.integer(y),Day=as.integer(d),Reach=as.integer(r),
Effort=sum(d.data$Effort))
if(length(redd.codes)==1){new.redds<-data.frame(Redds=sum(d.data$redds))}
if(length(redd.codes)>1){new.redds<-t(as.data.frame(apply(d.data[,-(1:4)],MARGIN=2,FUN=sum)))}
out.data<-rbind(out.data[-d.rows,],cbind(new.data,new.redds))
}
# carry over any covariates
var.col<-names(shape.edges)[names(shape.edges)%in%c("from","to","reachid","geometry")==F]
reach.match<-match(out.data$Reach,shape.edges$reachid)
out.data<-cbind(out.data,as.data.frame(shape.edges)[reach.match,var.col])
rownames(out.data)<-NULL
out.data
# Read in some data
data.list<-LoadStreamData(watershed = "East_Fork_Lewis",size = 2000)
Redd.data
data.list[[1]]
out.data
str(out.data)
is.data.frame(out.data)
class(out.data)
devtools::document()
devtools::document(pkg = "StreamVAST")
warnings()
